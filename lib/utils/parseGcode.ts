/**
 * Parser robusto de arquivos GCode
 * Extrai metadados de fatiamento de Bambu Studio, Orca Slicer, PrusaSlicer e outros
 */

export interface GCodeMaterial {
  slot_index: number;
  name: string;
  type: string;
  weight_grams: number;
  length_m?: number;
  color?: string;
}

export interface GCodePrintSettings {
  layer_height?: number;
  infill_percent?: number;
  wall_count?: number;
  support_enabled?: boolean;
  brim_enabled?: boolean;
  nozzle_temp?: number;
  bed_temp?: number;
  speed_profile?: string;
  filament_change_count?: number;
}

export interface GCodeParseResult {
  success: boolean;
  estimated_time_minutes: number | null;
  total_weight_grams: number | null;
  materials: GCodeMaterial[];
  print_settings: GCodePrintSettings;
  slicer_name?: string;
  slicer_version?: string;
  errors: string[];
}

/**
 * Parse completo de arquivo GCode
 */
export function parseGCode(gcodeContent: string): GCodeParseResult {
  const result: GCodeParseResult = {
    success: false,
    estimated_time_minutes: null,
    total_weight_grams: null,
    materials: [],
    print_settings: {},
    errors: [],
  };

  try {
    // Extrair apenas os comentÃ¡rios do header (primeiras ~500 linhas)
    const lines = gcodeContent.split("\n").slice(0, 500);
    const headerLines = lines.filter((line) => line.trim().startsWith(";"));
    const headerText = headerLines.join("\n");

    // Detectar slicer
    detectSlicer(headerText, result);

    // Extrair tempo estimado
    extractEstimatedTime(headerText, result);

    // Extrair materiais e pesos
    extractMaterials(headerText, result);

    // Extrair configuraÃ§Ãµes de impressÃ£o
    extractPrintSettings(headerText, result);

    // Validar se conseguiu algo Ãºtil
    if (
      result.estimated_time_minutes ||
      result.total_weight_grams ||
      result.materials.length > 0
    ) {
      result.success = true;
    } else {
      result.errors.push("NÃ£o foi possÃ­vel extrair informaÃ§Ãµes Ãºteis do GCode");
    }
  } catch (error: any) {
    result.errors.push(`Erro ao processar GCode: ${error.message}`);
  }

  return result;
}

/**
 * Detecta qual slicer gerou o GCode
 */
function detectSlicer(headerText: string, result: GCodeParseResult): void {
  const slicerPatterns = [
    {
      pattern: /;\s*generated by BambuStudio\s*([^\n]+)?/i,
      name: "Bambu Studio",
    },
    {
      pattern: /;\s*generated by OrcaSlicer\s*([^\n]+)?/i,
      name: "Orca Slicer",
    },
    {
      pattern: /;\s*generated by PrusaSlicer\s*([^\n]+)?/i,
      name: "PrusaSlicer",
    },
    { pattern: /;\s*generated by Cura_SteamEngine\s*([^\n]+)?/i, name: "Cura" },
  ];

  for (const { pattern, name } of slicerPatterns) {
    const match = headerText.match(pattern);
    if (match) {
      result.slicer_name = name;
      result.slicer_version = match[1]?.trim() || "";
      break;
    }
  }
}

/**
 * Extrai tempo estimado de impressÃ£o
 */
function extractEstimatedTime(
  headerText: string,
  result: GCodeParseResult,
): void {
  // PadrÃ£o 1: "Xh Ym Zs" ou "Xh Ym" ou "Ym Zs" - ordem e formato variados
  // Bambu/Orca: "; estimated printing time (normal mode) = 2h 34m 15s"
  const hmsPattern = /;\s*(?:estimated printing time|total estimated time)[^=]*=\s*(?:(\d+)\s*h)?\s*(?:(\d+)\s*m)?\s*(?:(\d+)\s*s)?/i;
  const hmsMatch = headerText.match(hmsPattern);
  if (hmsMatch && (hmsMatch[1] || hmsMatch[2] || hmsMatch[3])) {
    const hours = parseInt(hmsMatch[1] || "0");
    const minutes = parseInt(hmsMatch[2] || "0");
    const seconds = parseInt(hmsMatch[3] || "0");
    result.estimated_time_minutes = hours * 60 + minutes + Math.round(seconds / 60);
    if (result.estimated_time_minutes > 0) return;
  }

  // PadrÃ£o 2: Formato com vÃ­rgula/ponto decimal para minutos
  // "; estimated printing time = 154.5min"
  const minDecPattern = /;\s*(?:estimated printing time|print time)[^=]*=\s*(\d+\.?\d*)\s*min/i;
  const minDecMatch = headerText.match(minDecPattern);
  if (minDecMatch) {
    result.estimated_time_minutes = Math.round(parseFloat(minDecMatch[1]));
    if (result.estimated_time_minutes > 0) return;
  }

  // PadrÃ£o 3: TIME em segundos (Cura e outros)
  // "; TIME:7425"
  const timeSecsPattern = /;\s*TIME:\s*(\d+)/i;
  const timeSecsMatch = headerText.match(timeSecsPattern);
  if (timeSecsMatch) {
    const totalSeconds = parseInt(timeSecsMatch[1]);
    result.estimated_time_minutes = Math.round(totalSeconds / 60);
    if (result.estimated_time_minutes > 0) return;
  }

  // PadrÃ£o 4: Formato Bambu "total estimated time" separado
  // "; total estimated time = 12345" (segundos)
  const totalTimePattern = /;\s*total estimated time\s*[:=]\s*(\d+)/i;
  const totalTimeMatch = headerText.match(totalTimePattern);
  if (totalTimeMatch) {
    result.estimated_time_minutes = Math.round(parseInt(totalTimeMatch[1]) / 60);
    if (result.estimated_time_minutes > 0) return;
  }

  // PadrÃ£o 5: Formato separado por ":" (HH:MM:SS)
  // "; Print Time: 02:34:15"
  const colonPattern = /;\s*(?:print time|estimated time)\s*[:=]\s*(\d+):(\d+):(\d+)/i;
  const colonMatch = headerText.match(colonPattern);
  if (colonMatch) {
    const hours = parseInt(colonMatch[1]);
    const minutes = parseInt(colonMatch[2]);
    const seconds = parseInt(colonMatch[3]);
    result.estimated_time_minutes = hours * 60 + minutes + Math.round(seconds / 60);
    return;
  }
}

/**
 * Extrai materiais e pesos (multi-filamento)
 */
function extractMaterials(headerText: string, result: GCodeParseResult): void {
  // ESTRATÃ‰GIA 1: Bambu/Orca com breakdown por filamento (mais comum)
  // "; filament used [g] = 12.34, 23.45, 34.56"
  // "; filament used [mm] = 4123.45, 8234.56"
  let weightBreakdown = headerText.match(
    /;\s*filament used \[g\]\s*=\s*([0-9., ]+)/i,
  );
  
  // Formato alternativo Bambu: "; filament_used_g = 12.34"
  if (!weightBreakdown) {
    weightBreakdown = headerText.match(/;\s*filament_used_g\s*=\s*([0-9., ]+)/i);
  }
  
  const lengthBreakdown = headerText.match(
    /;\s*filament used \[mm\]\s*=\s*([0-9., ]+)/i,
  );

  if (weightBreakdown) {
    const weights = weightBreakdown[1]
      .split(",")
      .map((w) => parseFloat(w.trim()))
      .filter((w) => !isNaN(w) && w > 0);
    const lengths = lengthBreakdown
      ? lengthBreakdown[1]
          .split(",")
          .map((l) => parseFloat(l.trim()) / 1000)
          .filter((l) => !isNaN(l))
      : [];

    if (weights.length > 0) {
      weights.forEach((weight, index) => {
        result.materials.push({
          slot_index: index + 1,
          name: `Filamento ${index + 1}`,
          type: "PLA", // Default, pode ser sobrescrito
          weight_grams: weight,
          length_m: lengths[index],
        });
      });

      result.total_weight_grams = weights.reduce((sum, w) => sum + w, 0);
    }
  }

  // ESTRATÃ‰GIA 2: Bambu/Orca com tipos de filamento
  // "; filament_type = PLA;PLA;PETG" ou "; filament_type = PLA, PLA, PETG"
  if (result.materials.length > 0) {
    const filamentTypes = headerText.match(/;\s*filament_type\s*=\s*([^\n]+)/i);
    if (filamentTypes) {
      // Pode usar ; ou , como separador
      const types = filamentTypes[1].split(/[;,]/).map((t) => t.trim()).filter(t => t.length > 0);
      result.materials.forEach((mat, index) => {
        if (types[index]) {
          mat.type = types[index];
        }
      });
    }
  }

  // ESTRATÃ‰GIA 3: Peso total Ãºnico (sem breakdown)
  if (result.materials.length === 0) {
    const totalWeightPatterns = [
      /;\s*total filament used \[g\]\s*=\s*(\d+\.?\d*)/i,
      /;\s*filament used\s*=\s*(\d+\.?\d*)\s*g/i,
      /;\s*Filament used:\s*(\d+\.?\d*)\s*g/i,
      /;\s*filament_weight_g\s*=\s*(\d+\.?\d*)/i,
      /;\s*FILAMENT_USED:\s*(\d+\.?\d*)/i,
      // Cura: "; Filament used: 1.23456m" (converter metros para gramas)
      /;\s*Filament used:\s*(\d+\.?\d*)m/i,
    ];

    for (const pattern of totalWeightPatterns) {
      const match = headerText.match(pattern);
      if (match) {
        let weight = parseFloat(match[1]);
        // Se for em metros, converter para gramas (assumindo PLA 1.75mm: ~3g/m)
        if (pattern.source.includes('m/i')) {
          weight = weight * 3;
        }
        if (!isNaN(weight) && weight > 0) {
          result.total_weight_grams = weight;
          result.materials.push({
            slot_index: 1,
            name: "Filamento Ãšnico",
            type: "PLA",
            weight_grams: weight,
          });
          break;
        }
      }
    }
  }

  // ESTRATÃ‰GIA 4: Calcular peso a partir do comprimento se nÃ£o tiver peso
  if (result.materials.length === 0 && lengthBreakdown) {
    const lengths = lengthBreakdown[1]
      .split(",")
      .map((l) => parseFloat(l.trim()) / 1000) // mm para metros
      .filter((l) => !isNaN(l) && l > 0);
    
    if (lengths.length > 0) {
      // PLA 1.75mm: ~3g por metro
      lengths.forEach((lengthM, index) => {
        const weight = lengthM * 3; // AproximaÃ§Ã£o
        result.materials.push({
          slot_index: index + 1,
          name: `Filamento ${index + 1}`,
          type: "PLA",
          weight_grams: Math.round(weight * 100) / 100,
          length_m: lengthM,
        });
      });
      result.total_weight_grams = result.materials.reduce((sum, m) => sum + m.weight_grams, 0);
    }
  }

  // ESTRATÃ‰GIA 5: Bambu/Orca com nomes de filamento
  // "; filament_settings_id = Generic PLA @BBL X1C;Bambu PLA Basic @BBL X1C"
  if (result.materials.length > 0) {
    const filamentNames = headerText.match(
      /;\s*filament_settings_id\s*=\s*([^\n]+)/i,
    );
    if (filamentNames) {
      const names = filamentNames[1].split(/[;,]/).map((n) => n.trim()).filter(n => n.length > 0);
      result.materials.forEach((mat, index) => {
        if (names[index]) {
          mat.name = names[index].replace(/@.*$/, "").trim();
        }
      });
    }
  }
}

/**
 * Extrai configuraÃ§Ãµes de impressÃ£o
 */
function extractPrintSettings(
  headerText: string,
  result: GCodeParseResult,
): void {
  const settings = result.print_settings;

  // Layer height
  const layerHeight = headerText.match(/;\s*layer_height\s*=\s*(\d+\.?\d*)/i);
  if (layerHeight) settings.layer_height = parseFloat(layerHeight[1]);

  // Infill
  const infill = headerText.match(/;\s*fill_density\s*=\s*(\d+\.?\d*)%?/i);
  if (infill) settings.infill_percent = parseFloat(infill[1]);

  // Walls/Perimeters
  const walls = headerText.match(/;\s*(?:wall_loops|perimeters)\s*=\s*(\d+)/i);
  if (walls) settings.wall_count = parseInt(walls[1]);

  // Supports
  const supports = headerText.match(
    /;\s*support_enable\s*=\s*(\d|true|false)/i,
  );
  if (supports) {
    settings.support_enabled = supports[1] === "1" || supports[1] === "true";
  }

  // Brim
  const brim = headerText.match(
    /;\s*(?:brim_width|skirt_distance)\s*=\s*(\d+\.?\d*)/i,
  );
  if (brim) {
    const width = parseFloat(brim[1]);
    settings.brim_enabled = width > 0;
  }

  // Temperaturas
  const nozzleTemp = headerText.match(
    /;\s*(?:nozzle_temperature|temperature)\s*=\s*(\d+)/i,
  );
  if (nozzleTemp) settings.nozzle_temp = parseInt(nozzleTemp[1]);

  const bedTemp = headerText.match(/;\s*bed_temperature\s*=\s*(\d+)/i);
  if (bedTemp) settings.bed_temp = parseInt(bedTemp[1]);

  // Speed profile
  const speed = headerText.match(/;\s*print_settings_id\s*=\s*([^;\n]+)/i);
  if (speed) settings.speed_profile = speed[1].trim();

  // Filament changes (M600 ou T comandos)
  const filamentChanges = (headerText.match(/M600/g) || []).length;
  const toolChanges = (headerText.match(/T\d+/g) || []).length;
  if (filamentChanges > 0 || toolChanges > 0) {
    settings.filament_change_count = Math.max(filamentChanges, toolChanges);
  }
}

/**
 * Testa o parser com exemplos comuns
 */
export function testGCodeParser() {
  console.log("ðŸ§ª Testando parser de GCode...\n");

  // Teste 1: Bambu Studio multi-color
  const bambuMulti = `
; generated by BambuStudio 01.09.05.52 on 2024-01-15 at 14:32:15 UTC
; estimated printing time (normal mode) = 2h 34m 15s
; filament used [g] = 12.34, 23.45, 34.56
; filament used [mm] = 4123.45, 8234.56, 11456.78
; filament_type = PLA;PLA;PETG
; filament_settings_id = Generic PLA @BBL X1C;Bambu PLA Basic @BBL X1C;Generic PETG @BBL X1C
; layer_height = 0.2
; fill_density = 15%
; wall_loops = 2
; support_enable = 1
; nozzle_temperature = 220
; bed_temperature = 60
  `;

  const result1 = parseGCode(bambuMulti);
  console.log("âœ… Teste 1 (Bambu Multi):", JSON.stringify(result1, null, 2));

  // Teste 2: PrusaSlicer single color
  const prusaSingle = `
; generated by PrusaSlicer 2.6.1+win64 on 2024-01-15 at 10:20:30 UTC
; estimated printing time = 1h 23m 45s
; total filament used [g] = 45.67
; layer_height = 0.15
; fill_density = 20%
; perimeters = 3
  `;

  const result2 = parseGCode(prusaSingle);
  console.log("\nâœ… Teste 2 (Prusa Single):", JSON.stringify(result2, null, 2));

  console.log("\nâœ… Testes concluÃ­dos!");
}
