/**
 * Parser robusto de arquivos GCode
 * Extrai metadados de fatiamento de Bambu Studio, Orca Slicer, PrusaSlicer e outros
 */

export interface GCodeMaterial {
  slot_index: number;
  name: string;
  type: string;
  weight_grams: number;
  length_m?: number;
  color?: string;
}

export interface GCodePrintSettings {
  layer_height?: number;
  infill_percent?: number;
  wall_count?: number;
  support_enabled?: boolean;
  brim_enabled?: boolean;
  nozzle_temp?: number;
  bed_temp?: number;
  speed_profile?: string;
  filament_change_count?: number;
}

export interface GCodeParseResult {
  success: boolean;
  estimated_time_minutes: number | null;
  total_weight_grams: number | null;
  materials: GCodeMaterial[];
  print_settings: GCodePrintSettings;
  slicer_name?: string;
  slicer_version?: string;
  errors: string[];
}

/**
 * Parse completo de arquivo GCode
 */
export function parseGCode(gcodeContent: string): GCodeParseResult {
  const result: GCodeParseResult = {
    success: false,
    estimated_time_minutes: null,
    total_weight_grams: null,
    materials: [],
    print_settings: {},
    errors: [],
  };

  try {
    // Extrair apenas os comentÃ¡rios do header (primeiras ~500 linhas)
    const lines = gcodeContent.split("\n").slice(0, 500);
    const headerLines = lines.filter((line) => line.trim().startsWith(";"));
    const headerText = headerLines.join("\n");

    // Detectar slicer
    detectSlicer(headerText, result);

    // Extrair tempo estimado
    extractEstimatedTime(headerText, result);

    // Extrair materiais e pesos
    extractMaterials(headerText, result);

    // Extrair configuraÃ§Ãµes de impressÃ£o
    extractPrintSettings(headerText, result);

    // Validar se conseguiu algo Ãºtil
    if (
      result.estimated_time_minutes ||
      result.total_weight_grams ||
      result.materials.length > 0
    ) {
      result.success = true;
    } else {
      result.errors.push("NÃ£o foi possÃ­vel extrair informaÃ§Ãµes Ãºteis do GCode");
    }
  } catch (error: any) {
    result.errors.push(`Erro ao processar GCode: ${error.message}`);
  }

  return result;
}

/**
 * Detecta qual slicer gerou o GCode
 */
function detectSlicer(headerText: string, result: GCodeParseResult): void {
  const slicerPatterns = [
    {
      pattern: /;\s*generated by BambuStudio\s*([^\n]+)?/i,
      name: "Bambu Studio",
    },
    {
      pattern: /;\s*generated by OrcaSlicer\s*([^\n]+)?/i,
      name: "Orca Slicer",
    },
    {
      pattern: /;\s*generated by PrusaSlicer\s*([^\n]+)?/i,
      name: "PrusaSlicer",
    },
    { pattern: /;\s*generated by Cura_SteamEngine\s*([^\n]+)?/i, name: "Cura" },
  ];

  for (const { pattern, name } of slicerPatterns) {
    const match = headerText.match(pattern);
    if (match) {
      result.slicer_name = name;
      result.slicer_version = match[1]?.trim() || "";
      break;
    }
  }
}

/**
 * Extrai tempo estimado de impressÃ£o
 */
function extractEstimatedTime(
  headerText: string,
  result: GCodeParseResult,
): void {
  const timePatterns = [
    // Bambu/Orca: "; estimated printing time (normal mode) = 2h 34m 15s"
    /;\s*estimated printing time[^=]*=\s*(?:(\d+)h\s*)?(?:(\d+)m\s*)?(?:(\d+)s)?/i,

    // Prusa: "; estimated printing time = 1h 23m 45s"
    /;\s*estimated printing time\s*=\s*(?:(\d+)h\s*)?(?:(\d+)m\s*)?(?:(\d+)s)?/i,

    // Formato alternativo: "; TIME:7425" (segundos)
    /;\s*TIME:\s*(\d+)/i,

    // Cura: ";TIME:12345"
    /;\s*TIME:\s*(\d+)/i,
  ];

  for (const pattern of timePatterns) {
    const match = headerText.match(pattern);
    if (match) {
      if (
        match[1] !== undefined &&
        (match[2] !== undefined || match[3] !== undefined)
      ) {
        // Formato "Xh Ym Zs"
        const hours = parseInt(match[1] || "0");
        const minutes = parseInt(match[2] || "0");
        const seconds = parseInt(match[3] || "0");
        result.estimated_time_minutes =
          hours * 60 + minutes + Math.round(seconds / 60);
        return;
      } else if (match[1] && !match[2]) {
        // Formato "TIME:XXXXX" (segundos)
        const totalSeconds = parseInt(match[1]);
        result.estimated_time_minutes = Math.round(totalSeconds / 60);
        return;
      }
    }
  }
}

/**
 * Extrai materiais e pesos (multi-filamento)
 */
function extractMaterials(headerText: string, result: GCodeParseResult): void {
  // ESTRATÃ‰GIA 1: Bambu/Orca com breakdown por filamento
  // "; filament used [g] = 12.34, 23.45, 34.56"
  // "; filament used [mm] = 4123.45, 8234.56"
  const weightBreakdown = headerText.match(
    /;\s*filament used \[g\]\s*=\s*([0-9., ]+)/i,
  );
  const lengthBreakdown = headerText.match(
    /;\s*filament used \[mm\]\s*=\s*([0-9., ]+)/i,
  );

  if (weightBreakdown) {
    const weights = weightBreakdown[1]
      .split(",")
      .map((w) => parseFloat(w.trim()))
      .filter((w) => !isNaN(w));
    const lengths = lengthBreakdown
      ? lengthBreakdown[1]
          .split(",")
          .map((l) => parseFloat(l.trim()) / 1000)
          .filter((l) => !isNaN(l))
      : [];

    weights.forEach((weight, index) => {
      result.materials.push({
        slot_index: index + 1,
        name: `Filamento ${index + 1}`,
        type: "PLA", // Default, pode ser sobrescrito
        weight_grams: weight,
        length_m: lengths[index],
      });
    });

    result.total_weight_grams = weights.reduce((sum, w) => sum + w, 0);
  }

  // ESTRATÃ‰GIA 2: Bambu/Orca com tipos de filamento
  // "; filament_type = PLA;PLA;PETG"
  const filamentTypes = headerText.match(/;\s*filament_type\s*=\s*([^;\n]+)/i);
  if (filamentTypes && result.materials.length > 0) {
    const types = filamentTypes[1].split(";").map((t) => t.trim());
    result.materials.forEach((mat, index) => {
      if (types[index]) {
        mat.type = types[index];
      }
    });
  }

  // ESTRATÃ‰GIA 3: Peso total Ãºnico (sem breakdown)
  if (result.materials.length === 0) {
    const totalWeightPatterns = [
      /;\s*total filament used \[g\]\s*=\s*(\d+\.?\d*)/i,
      /;\s*filament used\s*=\s*(\d+\.?\d*)\s*g/i,
      /;\s*Filament used:\s*(\d+\.?\d*)g/i,
    ];

    for (const pattern of totalWeightPatterns) {
      const match = headerText.match(pattern);
      if (match) {
        const weight = parseFloat(match[1]);
        if (!isNaN(weight) && weight > 0) {
          result.total_weight_grams = weight;
          result.materials.push({
            slot_index: 1,
            name: "Filamento Ãšnico",
            type: "PLA",
            weight_grams: weight,
          });
          break;
        }
      }
    }
  }

  // ESTRATÃ‰GIA 4: Bambu/Orca com nomes de filamento
  // "; filament_settings_id = Generic PLA @BBL X1C;Bambu PLA Basic @BBL X1C"
  const filamentNames = headerText.match(
    /;\s*filament_settings_id\s*=\s*([^;\n]+)/i,
  );
  if (filamentNames && result.materials.length > 0) {
    const names = filamentNames[1].split(";").map((n) => n.trim());
    result.materials.forEach((mat, index) => {
      if (names[index]) {
        mat.name = names[index].replace(/@.*$/, "").trim();
      }
    });
  }
}

/**
 * Extrai configuraÃ§Ãµes de impressÃ£o
 */
function extractPrintSettings(
  headerText: string,
  result: GCodeParseResult,
): void {
  const settings = result.print_settings;

  // Layer height
  const layerHeight = headerText.match(/;\s*layer_height\s*=\s*(\d+\.?\d*)/i);
  if (layerHeight) settings.layer_height = parseFloat(layerHeight[1]);

  // Infill
  const infill = headerText.match(/;\s*fill_density\s*=\s*(\d+\.?\d*)%?/i);
  if (infill) settings.infill_percent = parseFloat(infill[1]);

  // Walls/Perimeters
  const walls = headerText.match(/;\s*(?:wall_loops|perimeters)\s*=\s*(\d+)/i);
  if (walls) settings.wall_count = parseInt(walls[1]);

  // Supports
  const supports = headerText.match(
    /;\s*support_enable\s*=\s*(\d|true|false)/i,
  );
  if (supports) {
    settings.support_enabled = supports[1] === "1" || supports[1] === "true";
  }

  // Brim
  const brim = headerText.match(
    /;\s*(?:brim_width|skirt_distance)\s*=\s*(\d+\.?\d*)/i,
  );
  if (brim) {
    const width = parseFloat(brim[1]);
    settings.brim_enabled = width > 0;
  }

  // Temperaturas
  const nozzleTemp = headerText.match(
    /;\s*(?:nozzle_temperature|temperature)\s*=\s*(\d+)/i,
  );
  if (nozzleTemp) settings.nozzle_temp = parseInt(nozzleTemp[1]);

  const bedTemp = headerText.match(/;\s*bed_temperature\s*=\s*(\d+)/i);
  if (bedTemp) settings.bed_temp = parseInt(bedTemp[1]);

  // Speed profile
  const speed = headerText.match(/;\s*print_settings_id\s*=\s*([^;\n]+)/i);
  if (speed) settings.speed_profile = speed[1].trim();

  // Filament changes (M600 ou T comandos)
  const filamentChanges = (headerText.match(/M600/g) || []).length;
  const toolChanges = (headerText.match(/T\d+/g) || []).length;
  if (filamentChanges > 0 || toolChanges > 0) {
    settings.filament_change_count = Math.max(filamentChanges, toolChanges);
  }
}

/**
 * Testa o parser com exemplos comuns
 */
export function testGCodeParser() {
  console.log("ðŸ§ª Testando parser de GCode...\n");

  // Teste 1: Bambu Studio multi-color
  const bambuMulti = `
; generated by BambuStudio 01.09.05.52 on 2024-01-15 at 14:32:15 UTC
; estimated printing time (normal mode) = 2h 34m 15s
; filament used [g] = 12.34, 23.45, 34.56
; filament used [mm] = 4123.45, 8234.56, 11456.78
; filament_type = PLA;PLA;PETG
; filament_settings_id = Generic PLA @BBL X1C;Bambu PLA Basic @BBL X1C;Generic PETG @BBL X1C
; layer_height = 0.2
; fill_density = 15%
; wall_loops = 2
; support_enable = 1
; nozzle_temperature = 220
; bed_temperature = 60
  `;

  const result1 = parseGCode(bambuMulti);
  console.log("âœ… Teste 1 (Bambu Multi):", JSON.stringify(result1, null, 2));

  // Teste 2: PrusaSlicer single color
  const prusaSingle = `
; generated by PrusaSlicer 2.6.1+win64 on 2024-01-15 at 10:20:30 UTC
; estimated printing time = 1h 23m 45s
; total filament used [g] = 45.67
; layer_height = 0.15
; fill_density = 20%
; perimeters = 3
  `;

  const result2 = parseGCode(prusaSingle);
  console.log("\nâœ… Teste 2 (Prusa Single):", JSON.stringify(result2, null, 2));

  console.log("\nâœ… Testes concluÃ­dos!");
}
